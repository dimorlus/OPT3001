/*********************************************************************
This is a library for our Monochrome OLEDs based on SSD1306 drivers

  Pick one up today in the adafruit shop!
  ------> http://www.adafruit.com/category/63_98

These displays use SPI to communicate, 4 or 5 pins are required to  
interface

Adafruit invests time and resources providing this open source code, 
please support Adafruit and open-source hardware by purchasing 
products from Adafruit!

Written by Limor Fried/Ladyada  for Adafruit Industries.  
BSD license, check license.txt for more information
All text above, and the splash screen below must be included in any redistribution
 *********************************************************************/
#include <plib.h>
#include <xc.h>
#include "types.h"
#include "SSD1306.h"


//------------------------------------------------------------------------------


#if defined SSD1306_128_64
#define SSD1306_LCDWIDTH                  128
#define SSD1306_LCDHEIGHT                 64
#endif
#if defined SSD1306_128_32
#define SSD1306_LCDWIDTH                  128
#define SSD1306_LCDHEIGHT                 32
#endif

#define SSD1306_DEFAULT_SPACE             5

#define SSD1306_SETCONTRAST               0x81
#define SSD1306_DISPLAYALLON_RESUME       0xA4
#define SSD1306_DISPLAYALLON              0xA5
#define SSD1306_NORMALDISPLAY             0xA6
#define SSD1306_INVERTDISPLAY             0xA7
#define SSD1306_DISPLAYOFF                0xAE
#define SSD1306_DISPLAYON                 0xAF

#define SSD1306_SETDISPLAYOFFSET          0xD3
#define SSD1306_SETCOMPINS                0xDA

#define SSD1306_SETVCOMDETECT             0xDB

#define SSD1306_SETDISPLAYCLOCKDIV        0xD5
#define SSD1306_SETPRECHARGE              0xD9

#define SSD1306_SETMULTIPLEX              0xA8

#define SSD1306_SETLOWCOLUMN              0x00
#define SSD1306_SETHIGHCOLUMN             0x10

#define SSD1306_SETSTARTLINE              0x40

#define SSD1306_MEMORYMODE                0x20
#define SSD1306_COLUMNADDR                0x21
#define SSD1306_PAGEADDR                  0x22

#define SSD1306_COMSCANINC                0xC0
#define SSD1306_COMSCANDEC                0xC8

#define SSD1306_SEGREMAP                  0xA0

#define SSD1306_CHARGEPUMP                0x8D

//#define SSD1306_EXTERNALVCC 0x1
//#define SSD1306_SWITCHCAPVCC 0x2

// Scrolling #defines
#define SSD1306_ACTIVATE_SCROLL           0x2F
#define SSD1306_DEACTIVATE_SCROLL         0x2E
#define SSD1306_SET_VERTICAL_SCROLL_AREA  0xA3
#define SSD1306_RIGHT_HORIZONTAL_SCROLL   0x26
#define SSD1306_LEFT_HORIZONTAL_SCROLL    0x27
#define SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL  0x29
#define SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL   0x2A

//------------------------------------------------------------------------------
//#define WAIT     0  /* 5ms delay after write operation. Polling ACK if 0 */

/*RB9 SDA operations*/
#define SDA_PIN     BIT_9
#define SDA_SET     TRISBSET = SDA_PIN
#define SDA_CLR     TRISBCLR = SDA_PIN
#define IS_SDA      ((PORTB & SDA_PIN) != 0)

/*RB8 SCL operations*/
#define SCL_PIN     BIT_8
#define SCL_SET     TRISBSET = SCL_PIN
#define SCL_CLR     TRISBCLR = SCL_PIN
#define IS_SCL      ((PORTB & SCL_PIN) != 0)

//---------------------------------------------------------------------------
// the memory buffer for the LCD
#ifdef LOGO
static uint8_t ssd1306_buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xC0, 0x80, 0x80, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xBF, 0xFF, 0xE3, 0xE3, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0x3C, 0x1C, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0xC0, 0xF0, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0xC0, 0xF8, 0xF8, 0x0C, 0x0C, 0x78, 0x78, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0x1C, 0x1C, 0x1C, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0x1C, 0x1C, 0x1C, 0x1C, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0xC0, 0xF8, 0xF8, 0x88, 0x8C, 0x88, 0xF8, 0xF0, 0xC0, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0xC0, 0xF0, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE0, 0xF0, 0xFE, 0xE7, 0xE3, 0xE0, 0xE0, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3E, 0x0F, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x7F, 0x7F, 0x40, 0xC0, 0x7C, 0x7C, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xC0, 0xFF, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x3F, 0x7F, 0x41, 0xC1, 0x41, 0x7D, 0x3D, 0x0D, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3E, 0x0F, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xC0, 0x7C, 0x3C, 0x1C, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x04, 0xFC, 0xFC, 0xF8, 0x00, 0x00, 0x30, 0xBC, 0xBC, 0x06, 0xFC, 0xFC, 0xF0, 0x00, 0x00, 0xF0, 0xFC, 0xFC, 0x06, 0x3C, 0x3C, 0x20, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x80, 0x60, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xC6, 0xFE, 0x3C, 0x10, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x60, 0x60, 0xE0, 0xC0, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x80, 0x20, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x0F, 0x0F, 0x0E, 0x00, 0x00, 0x7F, 0x7F, 0x7F, 0x08, 0x0F, 0x0F, 0x07, 0x00, 0x00, 0x06, 0x0F, 0x0F, 0x08, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x03, 0x0F, 0x0F, 0x18, 0x0F, 0x0F, 0x03, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x01, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x18, 0x1F, 0x0F, 0x06, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x18, 0x18, 0x0F, 0x0F, 0x03, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x01, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
#endif
#ifdef GTK_LOGO
static uint8_t ssd1306_buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xC0, 0xC0, 0xC0, 0xE0, 0xF0, 0xF0,
0x78, 0xF8, 0xFC, 0x3E, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xF8, 0xFC, 0x7C, 0x7E, 0x3E, 0x9F, 0xDF,
0xDF, 0xEF, 0xEF, 0xEF, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xFB, 0xFB, 0xF9, 0xFD, 0x7E,
0x1F, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xC0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFC, 0x7C, 0x7C, 0xFC, 0xFC, 0xF8, 0xF0, 0xF0, 0xC0, 0x80,
0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x0F, 0x8F, 0x9F, 0x9D, 0x9C, 0x1E, 0x1F, 0x3F, 0x3F, 0x3F,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x5F, 0x1F, 0x1F, 0x0F, 0x07, 0x07, 0x03, 0x81, 0x81, 0x80,
0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xF8, 0xF8, 0xF8, 0xFC, 0xF8,
0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xC0, 0x8F, 0xCF, 0x8F, 0xDF, 0x8F, 0xCF, 0x8A,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x15, 0xA0, 0xFC, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0x00, 0x00, 0xF0, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xD7, 0x87, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x50, 0x00, 0x55, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xB8, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0x00, 0x00, 0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x87,
0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xA0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0x3F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0x00, 0x00, 0x00, 0x00, 0xBB, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x03, 0xF7, 0xF3, 0xF7, 0xF3, 0xF7, 0xF3, 0x00, 0x00, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0x57, 0x03, 0x57, 0xF3, 0xF7, 0xF3, 0xF7, 0xF3, 0x57, 0x00, 0x55, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0x00, 0x00,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x55, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
0x07, 0xB3, 0xF7, 0xF3, 0xF7, 0xF3, 0xF7, 0xB2, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F, 0x1E, 0x1F, 0x0F, 0x07, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F,
0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F,
0x0F, 0x1F, 0x1F, 0x1F, 0x1E, 0x1E, 0x1F, 0x1F, 0x1F, 0x0F, 0x07, 0x03, 0x00, 0x00, 0x01, 0x07,
0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x1E, 0x1F, 0x1F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x15, 0x1F,
0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x0F, 0x1F, 0x1F, 0x1F, 0x0F, 0x1F, 0x0B, 0x00, 0x00,
0x1F, 0x1F, 0x1F, 0x0F, 0x1F, 0x1F, 0x15, 0x00, 0x00, 0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x1E,
0x1E, 0x1F, 0x1F, 0x1F, 0x1F, 0x07, 0x07, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
0x00, 0x03, 0x1F, 0x0F, 0x1F, 0x1F, 0x1F, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x54, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0x54, 0x00,
0xC0, 0xE0, 0x30, 0x30, 0x30, 0x20, 0xF0, 0x00, 0x00, 0xFE, 0xFC, 0x20, 0x10, 0x30, 0x70, 0xE0,
0x00, 0x30, 0xFC, 0xFC, 0x30, 0x00, 0x54, 0xE6, 0x00, 0x00, 0xF0, 0x60, 0x30, 0x30, 0x30, 0xE0,
0x40, 0x00, 0xC0, 0xE0, 0x30, 0x30, 0x30, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x15, 0x1F, 0x18, 0x18, 0x10, 0x18, 0x18, 0x08, 0x00, 0x1F, 0x15, 0x00,
0x47, 0xEE, 0xD8, 0x98, 0xD0, 0xC8, 0x7F, 0x00, 0x00, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x15, 0x1F,
0x00, 0x00, 0x0F, 0x1F, 0x10, 0x00, 0x15, 0x1F, 0x00, 0x00, 0x1F, 0x08, 0x00, 0x00, 0x00, 0x1F,
0x15, 0x00, 0x47, 0xEE, 0xD8, 0x98, 0xD8, 0xCC, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif

#ifdef ADAFRUIT_LOGO
static uint8_t ssd1306_buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
 0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
 0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
 0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
 0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
 0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
 0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
 0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
 0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SSD1306_LCDHEIGHT == 64)
 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
 0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
 0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
 0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
 0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
 0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
 0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
 0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
 0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
 0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
 0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
};
#endif

#define WIDTH   128 //SSD1306_LCDWIDTH
#define HEIGHT  64 //SSD1306_LCDHEIGHT // This is the 'raw' display w/h - never changes

#define swap(x,y) { x = x + y; y = x - y; x = x - y; }

// Return the size of the display (per current rotation)
extern int16_t width(void);
extern int16_t height(void);
extern uint8_t getRotation(void);

//---------------------------------------------------------------------------
#ifdef SSD1306_DIRECT_DRAW
uint8_t LCD_X,LCD_Y;
const uint8_t ssd1306_font[][22] = {
  {0x00, 0x00, 0x00, 0x00, 0x00},// (space)
  {0x00, 0x00, 0x5F, 0x00, 0x00},// !
  {0x00, 0x07, 0x00, 0x07, 0x00},// "
  {0x14, 0x7F, 0x14, 0x7F, 0x14},// #
  {0x24, 0x2A, 0x7F, 0x2A, 0x12},// $
  {0x23, 0x13, 0x08, 0x64, 0x62},// %
  {0x36, 0x49, 0x55, 0x22, 0x50},// &
  {0x00, 0x05, 0x03, 0x00, 0x00},// '
  {0x00, 0x1C, 0x22, 0x41, 0x00},// (
  {0x00, 0x41, 0x22, 0x1C, 0x00},// )
  {0x08, 0x2A, 0x1C, 0x2A, 0x08},// *
  {0x08, 0x08, 0x3E, 0x08, 0x08},// +
  {0x00, 0x50, 0x30, 0x00, 0x00},// ,
  {0x08, 0x08, 0x08, 0x08, 0x08},// -
  {0x00, 0x30, 0x30, 0x00, 0x00},// .
  {0x20, 0x10, 0x08, 0x04, 0x02},// /
  {0x3E, 0x51, 0x49, 0x45, 0x3E},// 0
  {0x00, 0x42, 0x7F, 0x40, 0x00},// 1
  {0x42, 0x61, 0x51, 0x49, 0x46},// 2
  {0x21, 0x41, 0x45, 0x4B, 0x31},// 3
  {0x18, 0x14, 0x12, 0x7F, 0x10},// 4
  {0x27, 0x45, 0x45, 0x45, 0x39},// 5
  {0x3C, 0x4A, 0x49, 0x49, 0x30},// 6
  {0x01, 0x71, 0x09, 0x05, 0x03},// 7
  {0x36, 0x49, 0x49, 0x49, 0x36},// 8
  {0x06, 0x49, 0x49, 0x29, 0x1E},// 9
  {0x00, 0x36, 0x36, 0x00, 0x00},// :
  {0x00, 0x56, 0x36, 0x00, 0x00},// ;
  {0x00, 0x08, 0x14, 0x22, 0x41},// <
  {0x14, 0x14, 0x14, 0x14, 0x14},// =
  {0x41, 0x22, 0x14, 0x08, 0x00},// >
  {0x02, 0x01, 0x51, 0x09, 0x06},// ?
  {0x32, 0x49, 0x79, 0x41, 0x3E},// @
  {0x7E, 0x11, 0x11, 0x11, 0x7E},// A
  {0x7F, 0x49, 0x49, 0x49, 0x36},// B
  {0x3E, 0x41, 0x41, 0x41, 0x22},// C
  {0x7F, 0x41, 0x41, 0x22, 0x1C},// D
  {0x7F, 0x49, 0x49, 0x49, 0x41},// E
  {0x7F, 0x09, 0x09, 0x01, 0x01},// F
  {0x3E, 0x41, 0x41, 0x51, 0x32},// G
  {0x7F, 0x08, 0x08, 0x08, 0x7F},// H
  {0x00, 0x41, 0x7F, 0x41, 0x00},// I
  {0x20, 0x40, 0x41, 0x3F, 0x01},// J
  {0x7F, 0x08, 0x14, 0x22, 0x41},// K
  {0x7F, 0x40, 0x40, 0x40, 0x40},// L
  {0x7F, 0x02, 0x04, 0x02, 0x7F},// M
  {0x7F, 0x04, 0x08, 0x10, 0x7F},// N
  {0x3E, 0x41, 0x41, 0x41, 0x3E},// O
  {0x7F, 0x09, 0x09, 0x09, 0x06},// P
  {0x3E, 0x41, 0x51, 0x21, 0x5E},// Q
  {0x7F, 0x09, 0x19, 0x29, 0x46},// R
  {0x46, 0x49, 0x49, 0x49, 0x31},// S
  {0x01, 0x01, 0x7F, 0x01, 0x01},// T
  {0x3F, 0x40, 0x40, 0x40, 0x3F},// U
  {0x1F, 0x20, 0x40, 0x20, 0x1F},// V
  {0x7F, 0x20, 0x18, 0x20, 0x7F},// W
  {0x63, 0x14, 0x08, 0x14, 0x63},// X
  {0x03, 0x04, 0x78, 0x04, 0x03},// Y
  {0x61, 0x51, 0x49, 0x45, 0x43},// Z
  {0x00, 0x00, 0x7F, 0x41, 0x41},// [
  {0x02, 0x04, 0x08, 0x10, 0x20},// "\"
  {0x41, 0x41, 0x7F, 0x00, 0x00},// ]
  {0x04, 0x02, 0x01, 0x02, 0x04},// ^
  {0x40, 0x40, 0x40, 0x40, 0x40},// _
  {0x00, 0x01, 0x02, 0x04, 0x00},// `
  {0x20, 0x54, 0x54, 0x54, 0x78},// a
  {0x7F, 0x48, 0x44, 0x44, 0x38},// b
  {0x38, 0x44, 0x44, 0x44, 0x20},// c
  {0x38, 0x44, 0x44, 0x48, 0x7F},// d
  {0x38, 0x54, 0x54, 0x54, 0x18},// e
  {0x08, 0x7E, 0x09, 0x01, 0x02},// f
  {0x08, 0x14, 0x54, 0x54, 0x3C},// g
  {0x7F, 0x08, 0x04, 0x04, 0x78},// h
  {0x00, 0x44, 0x7D, 0x40, 0x00},// i
  {0x20, 0x40, 0x44, 0x3D, 0x00},// j
  {0x00, 0x7F, 0x10, 0x28, 0x44},// k
  {0x00, 0x41, 0x7F, 0x40, 0x00},// l
  {0x7C, 0x04, 0x18, 0x04, 0x78},// m
  {0x7C, 0x08, 0x04, 0x04, 0x78},// n
  {0x38, 0x44, 0x44, 0x44, 0x38},// o
  {0x7C, 0x14, 0x14, 0x14, 0x08},// p
  {0x08, 0x14, 0x14, 0x18, 0x7C},// q
  {0x7C, 0x08, 0x04, 0x04, 0x08},// r
  {0x48, 0x54, 0x54, 0x54, 0x20},// s
  {0x04, 0x3F, 0x44, 0x40, 0x20},// t
  {0x3C, 0x40, 0x40, 0x20, 0x7C},// u
  {0x1C, 0x20, 0x40, 0x20, 0x1C},// v
  {0x3C, 0x40, 0x30, 0x40, 0x3C},// w
  {0x44, 0x28, 0x10, 0x28, 0x44},// x
  {0x0C, 0x50, 0x50, 0x50, 0x3C},// y
  {0x44, 0x64, 0x54, 0x4C, 0x44},// z
  {0x00, 0x08, 0x36, 0x41, 0x00},// {
  {0x00, 0x00, 0x7F, 0x00, 0x00},// |
  {0x00, 0x41, 0x36, 0x08, 0x00},// }
  {0x02, 0x01, 0x02, 0x04, 0x02},// ~
  {0x08, 0x1C, 0x2A, 0x08, 0x08} // <-
};
#endif
//---------------------------------------------------------------------------

/* iic routines */
static void delay(void)
{
 Nop();
 Nop();
 Nop();
 Nop();
 ClearWDT();
}
//---------------------------------------------------------------------------

static void Delay(void) //5 - is about 300kHz SCL
{
 int i;
 for(i = 0; i < 5; i++) delay();
}
//---------------------------------------------------------------------------

/* SDA operations */
static BOOL is_sda()
{
 return (PORTB & SDA_PIN) ? true : false;
}
//---------------------------------------------------------------------------

static void sda_set(void)
{
 TRISBSET = SDA_PIN;
}
//---------------------------------------------------------------------------

static void sda_clr(void)
{
 TRISBCLR = SDA_PIN;
}
//---------------------------------------------------------------------------

/* SCL operations */
static void scl_set(void)
{
 LATBSET = SCL_PIN;
 TRISBCLR = SCL_PIN;
 TRISBSET = SCL_PIN;
 LATBCLR = SCL_PIN;
}
//---------------------------------------------------------------------------

static void scl_clr(void)
{
 TRISBCLR = SCL_PIN;
}
//---------------------------------------------------------------------------

/* init pins */
static void disp_iic_init(void)
{
 CNPUBSET = SDA_PIN; //sda pullup set
 CNPUBSET = SCL_PIN; //scl pullup set
 TRISBSET = SDA_PIN; //sda pin TRIS set (input, pin high)
 TRISBSET = SCL_PIN; //scl pin TRIS set (input)
 LATBCLR = SDA_PIN; //sda LAT clear (prepare to clear pin if TRIS = 0)
 LATBCLR = SCL_PIN; //scl LAT clear
 Delay();
}
//---------------------------------------------------------------------------

/* I2C BUS operations */
/*
 *
 *    -------------+         +---------+         +---------+         +---------+         +---------------------
SCL                |         |         |         |         |         |         |         |
 *                 +---------+         +---------+         +---------+         +---------+
SDA   --------+       +--------- - - - - - - - - - - - - - - - - - - - - - - - - - - -       +-----------------
 *            |       |          |||||||||||||||||||||||||||||||||||||||||||||||||||||       |
 *            +-------+          - - - - - - - - - - - - - - - - - - - - - - - - - - - ------+
 *          START                                                                           STOP
 */
//---------------------------------------------------------------------------

static void iic_start(void) //start condition
{
 sda_set(); //SDA = 1
 scl_set(); //SCL = 1
 Delay();
 sda_clr(); //SDA = 0
 Delay();
 scl_clr(); //SCL = 0
 Delay();
}
//---------------------------------------------------------------------------

static void iic_stop(void) //stop condition
{
 sda_clr(); //SDA = 0
 scl_clr(); //SCL = 0
 Delay();
 scl_set(); //SCL = 1
 Delay();
 sda_set(); //SDA = 1;
 Delay();
}
//---------------------------------------------------------------------------

static BOOL iic_ack(void) //get ack (nack_mcu)
{
 BOOL b;

 scl_set(); //SCL = 1;
 Delay();
 b = is_sda();
 scl_clr(); //SCL = 0;
 Delay();
 return b;
}
//---------------------------------------------------------------------------

static void iic_ack_clr(void) //clr ack (ack_mcu)
{
 sda_clr(); //SDA = 0;
 Delay();
 scl_set(); //SCL = 1;
 Delay();
 scl_clr(); //SCL = 0;
 Delay();
 sda_set();
 Delay();
}
//---------------------------------------------------------------------------

static void iic_put(uint8_t b) //send byte
{
 idx8 i;

 sda_clr(); //SDA = 0;
 scl_clr(); //SCL = 0;
 for(i = 0; i < 8; i++)
  {
   if (b & 0x80) sda_set(); //SDA = 1;
   else sda_clr(); //SDA = 0;
   b <<= 1;
   Delay();
   scl_set(); //SCL = 1
   Delay();
   scl_clr(); //SCL = 0
   Delay();
  }
 sda_set(); //SDA = 1;
 Delay();
}
//---------------------------------------------------------------------------

static uint8_t iic_get(void) //get byte
{
 idx8 i;
 u8 b = 0;

 sda_set(); //SDA = 1;
 for(i = 0; i < 8; i++)
  {
   scl_set(); //SCL = 1;
   Delay();
   b <<= 1;
   b |= is_sda();
   scl_clr(); //SCL = 0;
   Delay();
  }
 return b;
}
//---------------------------------------------------------------------------

static BOOL put_dsc(uint8_t Dsc) //send control byte with ACK polling
{
 int tryes = 0;
 do
  {
   iic_start();
   iic_put(Dsc);
   ClearWDT();
   if (++tryes > 150) return false;
  }
 while(iic_ack());
 return true;
}
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
static bool ssd1306_command(uint8_t cmd)
{
 disp_iic_init();
 Delay();
 iic_start();
 iic_put(0b01111000); //SSD1306_I2C_ADDRESS
 if (iic_ack()) return false;
 iic_put(0b00000000); // Co = 0, D/C = 0
 if (iic_ack()) return false;
 iic_put(cmd);
 if (iic_ack()) return false;
 iic_stop();
 return true;
}
//---------------------------------------------------------------------------
//static void ssd1306_commands(const uint8_t *cmd, int cnt)
//{
// disp_iic_init();
// Delay();
// iic_start();
// iic_put(0b01111000); //SSD1306_I2C_ADDRESS
// (void)iic_ack();
// do
//  {
//   iic_put(0b00000000); // Co = 0, D/C = 0
//   (void)iic_ack();
//   iic_put(*cmd++);
//   (void)iic_ack();
//  }
// while(cnt--);
// iic_stop();
//}
//---------------------------------------------------------------------------

static bool ssd1306_data(uint8_t dat)
{
 disp_iic_init();
 Delay();
 iic_start();
 iic_put(0b01111000); //SSD1306_I2C_ADDRESS
 if (iic_ack()) return false;
 iic_put(0b01000000); // Co = 0, D/C = 1
 if (iic_ack()) return false;
 iic_put(dat); // Co = 0, D/C = 0
 if (iic_ack()) return false;
 iic_stop();
 return true;
}
//---------------------------------------------------------------------------

static bool ssd1306_buff(const uint8_t *buf, int size)
{
 int i;
 disp_iic_init();
 Delay();
 iic_start();
 iic_put(0b01111000); //SSD1306_I2C_ADDRESS
 if (iic_ack()) return false;
 iic_put(0b01000000); // Co = 0, D/C = 1
 if (iic_ack()) return false;
 for(i = 0; i<size; i++)
  {
   iic_put(buf[i]);
   if (iic_ack()) return false;
  }
 iic_stop();
 return true;
}
//---------------------------------------------------------------------------
bool ssd1306_init(void)
{

 static const uint8_t init[]=
  #if defined SSD1306_128_64
  {
   SSD1306_DISPLAYOFF, // 0xAE
   SSD1306_SETDISPLAYCLOCKDIV, // 0xD5
   0x80, // the suggested ratio 0x80
   SSD1306_SETMULTIPLEX, // 0xA8
   0x3F,
   SSD1306_SETDISPLAYOFFSET, // 0xD3
   0x0, // no offset
   SSD1306_SETSTARTLINE | 0x0, // line #0
   SSD1306_CHARGEPUMP, // 0x8D
   0x14,
   SSD1306_MEMORYMODE, // 0x20
   0x00, // 0x0 act like ks0108
   SSD1306_SEGREMAP | 0x1,
   SSD1306_COMSCANDEC,
   SSD1306_SETCOMPINS, // 0xDA
   0x12,
   SSD1306_SETCONTRAST, // 0x81
   0xCF,
   SSD1306_SETPRECHARGE, // 0xd9
   0xF1,
   SSD1306_SETVCOMDETECT, // 0xDB
   0x40,
   SSD1306_DISPLAYALLON_RESUME, // 0xA4
   SSD1306_NORMALDISPLAY, // 0xA6
   SSD1306_DISPLAYON //--turn on oled panel
  };
  #endif
  #if defined SSD1306_128_32
  {
   // Init sequence for 128x32 OLED module
   SSD1306_DISPLAYOFF, // 0xAE
   SSD1306_SETDISPLAYCLOCKDIV, // 0xD5
   0x80, // the suggested ratio 0x80
   SSD1306_SETMULTIPLEX, // 0xA8
   0x1F,
   SSD1306_SETDISPLAYOFFSET, // 0xD3
   0x0, // no offset
   SSD1306_SETSTARTLINE | 0x0, // line #0
   SSD1306_CHARGEPUMP, // 0x8D
   0x14,
   SSD1306_MEMORYMODE, // 0x20
   0x00, // 0x0 act like ks0108
   SSD1306_SEGREMAP | 0x1,
   SSD1306_COMSCANDEC,
   SSD1306_SETCOMPINS, // 0xDA
   0x02,
   SSD1306_SETCONTRAST, // 0x81
   0x8F,
   SSD1306_SETPRECHARGE, // 0xd9
   0xF1,
   SSD1306_SETVCOMDETECT, // 0xDB
   0x40,
   SSD1306_DISPLAYALLON_RESUME, // 0xA4
   SSD1306_NORMALDISPLAY // 0xA6
  }
  #endif

 // set pin directions
 disp_iic_init();
 int i;
 for(i = 0; i < sizeof(init); i++) if (!ssd1306_command(init[i])) return false;
 return true;
}

//---------------------------------------------------------------------------
#ifdef SSD1306_DIRECT_DRAW
bool ssd1306_Goto(uint8_t x, uint8_t y)
 {
  LCD_X = x;
  LCD_Y = y;
  // send a bunch of data in one xmission
  if (!ssd1306_command(0xB0 + y)) return false;//set page address
  if (!ssd1306_command(x & 0xf)) return false;//set lower column address
  if (!ssd1306_command(0x10 | (x >> 4))) return false;//set higher column address
  return true;
 }
//---------------------------------------------------------------------------

bool ssd1306_draw8x8(uint8_t * buffer, uint8_t x, uint8_t y)
 {
  // send a bunch of data in one xmission
  if (!ssd1306_command(0xB0 + y)) return false;//set page address
  if (!ssd1306_command(x & 0xf)) return false;//set lower column address
  if (!ssd1306_command(0x10 | (x >> 4))) return false;//set higher column address
  if (!ssd1306_buff(buffer, 8)) return false;
  return true
 }
//---------------------------------------------------------------------------
bool ssd1306_Putch(char c)
 {
  if (!ssd1306_draw8x8((uint8_t*)&ssd1306_font[c-32],LCD_X,LCD_Y)) return false;
  LCD_X += 8;
  if(LCD_X > SSD1306_LCDWIDTH) LCD_X = SSD1306_DEFAULT_SPACE;
  return true;
 }
//---------------------------------------------------------------------------
bool ssd1306_Puts(char* str)
{
 while (*str)
  {
   if((LCD_X > SSD1306_LCDWIDTH)||(LCD_X < SSD1306_DEFAULT_SPACE))
     LCD_X=SSD1306_DEFAULT_SPACE;
   if (!ssd1306_Putch(*str++)) return false;
  }
 return true;
}
//---------------------------------------------------------------------------
#endif

//---------------------------------------------------------------------------

bool invertDisplay(uint8_t i)
{
 if (i) 
  {
   if (!ssd1306_command(SSD1306_INVERTDISPLAY)) return false;
  }
 else 
  {
   if (!ssd1306_command(SSD1306_NORMALDISPLAY)) return false;
  }
 return true;
}

//---------------------------------------------------------------------------


// startscrollright
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)

bool startscrollright(uint8_t start, uint8_t stop)
{
 if (!ssd1306_command(SSD1306_RIGHT_HORIZONTAL_SCROLL)) return false;
 if (!ssd1306_command(0X00)) return false;
 if (!ssd1306_command(start)) return false;
 if (!ssd1306_command(0X00)) return false;
 if (!ssd1306_command(stop)) return false;
 if (!ssd1306_command(0X00)) return false;
 if (!ssd1306_command(0XFF)) return false;
 if (!ssd1306_command(SSD1306_ACTIVATE_SCROLL)) return false;
 return true;
}

// startscrollleft
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)

bool startscrollleft(uint8_t start, uint8_t stop)
{
 if (!ssd1306_command(SSD1306_LEFT_HORIZONTAL_SCROLL)) return false;
 if (!ssd1306_command(0X00)) return false;
 if (!ssd1306_command(start)) return false;
 if (!ssd1306_command(0X00)) return false;
 if (!ssd1306_command(stop)) return false;
 if (!ssd1306_command(0X00)) return false;
 if (!ssd1306_command(0XFF)) return false;
 if (!ssd1306_command(SSD1306_ACTIVATE_SCROLL)) return false;
 return true;
}

// startscrolldiagright
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)

bool startscrolldiagright(uint8_t start, uint8_t stop)
 {
  if (!ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA)) return false;
  if (!ssd1306_command(0X00)) return false;
  if (!ssd1306_command(SSD1306_LCDHEIGHT)) return false;
  if (!ssd1306_command(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL)) return false;
  if (!ssd1306_command(0X00)) return false;
  if (!ssd1306_command(start)) return false;
  if (!ssd1306_command(0X00)) return false;
  if (!ssd1306_command(stop)) return false;
  if (!ssd1306_command(0X01)) return false;
  if (!ssd1306_command(SSD1306_ACTIVATE_SCROLL)) return false;
  return true;
 }

// startscrolldiagleft
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)

bool startscrolldiagleft(uint8_t start, uint8_t stop)
 {
  if (!ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA)) return false;
  if (!ssd1306_command(0X00)) return false;
  if (!ssd1306_command(SSD1306_LCDHEIGHT)) return false;
  if (!ssd1306_command(SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL)) return false;
  if (!ssd1306_command(0X00)) return false;
  if (!ssd1306_command(start)) return false;
  if (!ssd1306_command(0X00)) return false;
  if (!ssd1306_command(stop)) return false;
  if (!ssd1306_command(0X01)) return false;
  if (!ssd1306_command(SSD1306_ACTIVATE_SCROLL)) return false;
  return true;
 }

bool stopscroll(void)
{
 if (!ssd1306_command(SSD1306_DEACTIVATE_SCROLL)) return false;
 return true;
}

// Dim the display
// dim = true: display is dimmed
// dim = false: display is normal

static uint8_t contrast = 0xcf;
bool dim(bool dimm)
{
 if (dimm) contrast = 0; // Dimmed display
 else contrast = 0xCF;
 // the range of contrast to too small to be really useful
 // it is useful to dim the display
 if (!ssd1306_command(SSD1306_SETCONTRAST)) return false;
 if (!ssd1306_command(contrast)) return false;
 return true;
}

bool isDim(void)
{
 return (contrast == 0);
}

bool display(void)
{

  static const uint8_t disp[]=
  #if defined SSD1306_128_64
  {
   SSD1306_COLUMNADDR,
   0, // Column start address (0 = reset)
   127, // Column end address (127 = reset)
   SSD1306_PAGEADDR,
   0, // Page start address (0 = reset)
   7 // Page end address
  };
  #endif
  #if defined SSD1306_128_32
  {
   SSD1306_COLUMNADDR,
   0, // Column start address (0 = reset)
   127, // Column end address (127 = reset)
   SSD1306_PAGEADDR,
   0, // Page start address (0 = reset)
   3 // Page end address
  };
  #endif

 int i;

 for(i = 0; i < sizeof(disp); i++) if (!ssd1306_command(disp[i])) return false;
 for(i = 0; i <(SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 128); i++)
   if (!ssd1306_buff(&ssd1306_buffer[i*16], 16)) return false;
 return true;
}


// the most basic function, set a single pixel

void drawPixel(int16_t x, int16_t y, uint16_t color)
{
 if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
  return;

 // check rotation, move pixel around if necessary
 switch(getRotation())
  {
   case 1:
    swap(x, y);
    x = WIDTH - x - 1;
    break;
   case 2:
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    break;
   case 3:
    swap(x, y);
    y = HEIGHT - y - 1;
    break;
  }

 // x is which column
 if (color == WHITE)
  ssd1306_buffer[x + (y / 8) * SSD1306_LCDWIDTH] |= (1 << (y & 7));
 else
  ssd1306_buffer[x + (y / 8) * SSD1306_LCDWIDTH] &= ~(1 << (y & 7));
}

// clear everything

void clearDisplay(void)
{
 memset(ssd1306_buffer, 0, (SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8));
}

//inline void drawFastVLineInternal(int16_t x, int16_t y, int16_t h, uint16_t color) __attribute__((always_inline));
//inline void drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) __attribute__((always_inline));

static void drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color)
{
 // Do bounds/limit checks
 if (y < 0 || y >= HEIGHT)
  {
   return;
  }

 // make sure we don't try to draw below 0
 if (x < 0)
  {
   w += x;
   x = 0;
  }

 // make sure we don't go off the edge of the display
 if ((x + w) > WIDTH)
  {
   w = (HEIGHT - x);
  }

 // if our width is now negative, punt
 if (w <= 0)
  {
   return;
  }

 // set up the pointer for  movement through the buffer
 register uint8_t *pBuf = ssd1306_buffer;
 // adjust the buffer pointer for the current row
 pBuf += ((y / 8) * SSD1306_LCDWIDTH);
 // and offset x columns in
 pBuf += x;

 register uint8_t mask = 1 << (y & 7);

 if (color == WHITE)
  {
   while(w--)
    {
     *pBuf++ |= mask;
    }
  }
 else
  {
   mask = ~mask;
   while(w--)
    {
     *pBuf++ &= mask;
    }
  }
}

static void drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color)
{

 // do nothing if we're off the left or right side of the screen
 if (x < 0 || x >= WIDTH)
  {
   return;
  }

 // make sure we don't try to draw below 0
 if (__y < 0)
  {
   // __y is negative, this will subtract enough from __h to account for __y being 0
   __h += __y;
   __y = 0;
  }

 // make sure we don't go past the height of the display
 if ((__y + __h) > HEIGHT)
  {
   __h = (HEIGHT - __y);
  }

 // if our height is now negative, punt
 if (__h <= 0)
  {
   return;
  }

 // this display doesn't need ints for coordinates, use local byte registers for faster juggling
 register uint8_t y = __y;
 register uint8_t h = __h;

 // set up the pointer for fast movement through the buffer
 register uint8_t *pBuf = ssd1306_buffer;
 // adjust the buffer pointer for the current row
 pBuf += ((y / 8) * SSD1306_LCDWIDTH);
 // and offset x columns in
 pBuf += x;

 // do the first partial byte, if necessary - this requires some masking
 register uint8_t mod = (y & 7);
 if (mod)
  {
   // mask off the high n bits we want to set
   mod = 8 - mod;

   // note - lookup table results in a nearly 10% performance improvement in fill* functions
   // register uint8_t mask = ~(0xFF >> (mod));
   static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE};
   register uint8_t mask = premask[mod];

   // adjust the mask if we're not going to reach the end of this byte
   if (h < mod)
    {
     mask &= (0XFF >> (mod - h));
    }

   if (color == WHITE)
    {
     *pBuf |= mask;
    }
   else
    {
     *pBuf &= ~mask;
    }

   // fast exit if we're done here!
   if (h < mod)
    {
     return;
    }

   h -= mod;

   pBuf += SSD1306_LCDWIDTH;
  }


 // write solid bytes while we can - effectively doing 8 rows at a time
 if (h >= 8)
  {
   // store a local value to work with
   register uint8_t val = (color == WHITE) ? 255 : 0;

   do
    {
     // write our value in
     *pBuf = val;

     // adjust the buffer forward 8 rows worth of data
     pBuf += SSD1306_LCDWIDTH;

     // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
     h -= 8;
    }
   while(h >= 8);
  }

 // now do the final partial byte, if necessary
 if (h)
  {
   mod = h & 7;
   // this time we want to mask the low bits of the byte, vs the high bits we did above
   // register uint8_t mask = (1 << mod) - 1;
   // note - lookup table results in a nearly 10% performance improvement in fill* functions
   static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F};
   register uint8_t mask = postmask[mod];
   if (color == WHITE)
    {
     *pBuf |= mask;
    }
   else
    {
     *pBuf &= ~mask;
    }
  }
}


void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color)
{
 bool bSwap = false;
 switch(getRotation())
  {
   case 0:
    // 0 degree rotation, do nothing
    break;
   case 1:
    // 90 degree rotation, swap x & y for rotation, then invert x
    bSwap = true;
    swap(x, y);
    x = WIDTH - x - 1;
    break;
   case 2:
    // 180 degree rotation, invert x and y - then shift y around for height.
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    x -= (w - 1);
    break;
   case 3:
    // 270 degree rotation, swap x & y for rotation, then invert y  and adjust y for w (not to become h)
    bSwap = true;
    swap(x, y);
    y = HEIGHT - y - 1;
    y -= (w - 1);
    break;
  }

 if (bSwap)
  {
   drawFastVLineInternal(x, y, w, color);
  }
 else
  {
   drawFastHLineInternal(x, y, w, color);
  }
}


void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color)
{
 bool bSwap = false;
 switch(getRotation())
  {
   case 0:
    break;
   case 1:
    // 90 degree rotation, swap x & y for rotation, then invert x and adjust x for h (now to become w)
    bSwap = true;
    swap(x, y);
    x = WIDTH - x - 1;
    x -= (h - 1);
    break;
   case 2:
    // 180 degree rotation, invert x and y - then shift y around for height.
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    y -= (h - 1);
    break;
   case 3:
    // 270 degree rotation, swap x & y for rotation, then invert y
    bSwap = true;
    swap(x, y);
    y = HEIGHT - y - 1;
    break;
  }

 if (bSwap) drawFastHLineInternal(x, y, h, color);
 else drawFastVLineInternal(x, y, h, color);
}

